import { Meta } from '@storybook/blocks';

<Meta title="DesignPatterns/04-ObserverPattern" />

# ObserverPatterns

With the observer pattern, we can subscribe certain objects, the observers, to another object, called the observable. Whenever an event occurs, the observable notifies all its observers!
An observable object usually contains 3 important parts:
1. observers: an array of observers that will get notified whenever a specific event occurs
2. subscribe(): a method in order to add observers to the observers list
3. unsubscribe(): a method in order to remove observers from the observers list
4. notify(): a method to notify all observers whenever a specific event occurs
Note: below is the defacto implementation of the Observables
```js
class Observable {
  constructor() {
    this.observers = [];
  }

  subscribe(func) {
    this.observers.push(func);
  }

  unsubscribe(func) {
    this.observers = this.observers.filter((observer) => observer !== func);
  }

  notify(data) {
    this.observers.forEach((observer) => observer(data));
  }
}
```


A popular library that uses the observable pattern is RxJS.

# Advantages

Using the observer pattern is a great way to enforce separation of concerns and the single-responsiblity principle. The observer objects arenâ€™t tightly coupled to the observable object, and can be (de)coupled at any time. The observable object is responsible for monitoring the events, while the observers simply handle the received data.

# Cons
If an observer becomes too complex, it may cause performance issues when notifying all subscribers.